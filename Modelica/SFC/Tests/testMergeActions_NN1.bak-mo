within SFC.Tests;

model testMergeActions_NN1
  SFC.BasicBlocks.InitialStep S0 annotation(
    Placement(visible = true, transformation(origin = {-10, 76}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Step S1 annotation(
    Placement(visible = true, transformation(origin = {-10, 32}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Step S2 annotation(
    Placement(visible = true, transformation(origin = {-10, -12}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Step S3 annotation(
    Placement(visible = true, transformation(origin = {-10, -56}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T1 annotation(
    Placement(visible = true, transformation(origin = {-10, 54}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T2 annotation(
    Placement(visible = true, transformation(origin = {-10, 10}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T3 annotation(
    Placement(visible = true, transformation(origin = {-10, -34}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T4 annotation(
    Placement(visible = true, transformation(origin = {-10, -78}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C1(y = S0.t > 2) annotation(
    Placement(visible = true, transformation(origin = {20, 54}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C2(y = S1.t > 1) annotation(
    Placement(visible = true, transformation(origin = {20, 10}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C3(y = S2.t > 0.5) annotation(
    Placement(visible = true, transformation(origin = {20, -34}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C4(y = S3.t > 1.5) annotation(
    Placement(visible = true, transformation(origin = {20, -78}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Action A2(qualifierType = SFC.Types.Qualifier.N) annotation(
    Placement(visible = true, transformation(origin = {20, -12}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.mergeActions A(n = 2) annotation(
    Placement(visible = true, transformation(origin = {58, 32}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Action A0(initialStepAction = true, qualifierType = SFC.Types.Qualifier.N) annotation(
    Placement(visible = true, transformation(origin = {20, 76}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
equation
  connect(S2.X, A2.phase_active) annotation(
    Line(points = {{2, -12}, {10, -12}, {10, -12}, {10, -12}}, color = {255, 0, 255}));
  connect(A2.actionOUT, A.mergeIN[2]) annotation(
    Line(points = {{30, -12}, {40, -12}, {40, 32}, {48, 32}, {48, 32}}));
  connect(A0.actionOUT, A.mergeIN[1]) annotation(
    Line(points = {{30, 76}, {40, 76}, {40, 32}, {48, 32}, {48, 32}}));
  connect(S0.X, A0.phase_active) annotation(
    Line(points = {{2, 76}, {10, 76}, {10, 76}, {10, 76}}, color = {255, 0, 255}));
  connect(T1.C, C1.y) annotation(
    Line(points = {{2, 54}, {9, 54}}, color = {255, 0, 255}));
  connect(T2.C, C2.y) annotation(
    Line(points = {{2, 10}, {9, 10}}, color = {255, 0, 255}));
  connect(T3.C, C3.y) annotation(
    Line(points = {{2, -34}, {9, -34}}, color = {255, 0, 255}));
  connect(T4.C, C4.y) annotation(
    Line(points = {{2, -78}, {9, -78}}, color = {255, 0, 255}));
  connect(T4.OUT, S0.IN) annotation(
    Line(points = {{-10, -80}, {-10, -88}, {-34, -88}, {-34, 94}, {-10, 94}, {-10, 86}}));
  connect(S3.OUT, T4.IN) annotation(
    Line(points = {{-10, -66}, {-10, -76}}));
  connect(S2.OUT, T3.IN) annotation(
    Line(points = {{-10, -22}, {-10, -32}}));
  connect(T3.OUT, S3.IN) annotation(
    Line(points = {{-10, -36}, {-10, -46}}));
  connect(S1.OUT, T2.IN) annotation(
    Line(points = {{-10, 22}, {-10, 12}}));
  connect(T2.OUT, S2.IN) annotation(
    Line(points = {{-10, 8}, {-10, -2}}));
  connect(S0.OUT, T1.IN) annotation(
    Line(points = {{-10, 66}, {-10, 56}}));
  connect(T1.OUT, S1.IN) annotation(
    Line(points = {{-10, 52}, {-10, 42}}));
  annotation(
    Documentation(info = "<html><head></head><body><div><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"><span class=\"Apple-style-span\" style=\"font-size: 12px; \">Test &nbsp;performing a&nbsp;<b>merging</b>&nbsp;between two actions&nbsp;&nbsp;<b>N</b>, when the first one&nbsp;<b>is</b>&nbsp;associated to the<b>&nbsp;initial step</b>.<div><br></div><div>The output of the block MergeActions is expected to be a signal that has value true when action A0 is performed and that keeps that value until the associated step is deactivated. The same behaviour is expected for action A2.</div><div><br></div><div><div><b>A.y</b>&nbsp;signal will be true for the all duration of step S0 and S2 and it will be false for the all duration of steps S1 and S3.</div><div><br></div><div>Being the action N&nbsp;connected to the initial step,&nbsp;<b>A.y</b>&nbsp;is initialised true.</div></div><div><br></div><div><b>N.B.</b> it is possible to connect consecutive actions of type N (actions connected to consecutive steps). For example let us conseder the same system where action A2 is associated to step S1. In this case the output A.y would be true for all the suration of steps S0 and S1 and false for all the duration of steps S2 and S3. The output of this system is equivalent to the one seen in <i>testMergeActions_SR1</i>, so it is recommended to use the latter configuration. If two actions N are connected consecutively, and merged together, the second one will not be detected in A.y with a <i>when edge()</i>&nbsp; (see definition of when statement).</div></span></div><div><br></div><div><br></div><div><br></div>&nbsp;<img width=\"400\" src=\"modelica://SFC/Images/tests/testMergeActionsNN1_y.png\">
    
    </body></html>"),
    experiment(StartTime = 0, StopTime = 10, Tolerance = 1e-6, Interval = 0.02));
end testMergeActions_NN1;