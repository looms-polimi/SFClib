within SFC.Tests;

model testMergeActions_PP2
  SFC.BasicBlocks.InitialStep S0 annotation(
    Placement(visible = true, transformation(origin = {-10, 76}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Step S1 annotation(
    Placement(visible = true, transformation(origin = {-10, 32}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Step S2 annotation(
    Placement(visible = true, transformation(origin = {-10, -12}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Step S3 annotation(
    Placement(visible = true, transformation(origin = {-10, -56}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T1 annotation(
    Placement(visible = true, transformation(origin = {-10, 54}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T2 annotation(
    Placement(visible = true, transformation(origin = {-10, 10}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T3 annotation(
    Placement(visible = true, transformation(origin = {-10, -34}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T4 annotation(
    Placement(visible = true, transformation(origin = {-10, -78}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C1(y = S0.t > 2) annotation(
    Placement(visible = true, transformation(origin = {20, 54}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C2(y = S1.t > 1) annotation(
    Placement(visible = true, transformation(origin = {20, 10}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C3(y = S2.t > 0.5) annotation(
    Placement(visible = true, transformation(origin = {20, -34}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C4(y = S3.t > 1.5) annotation(
    Placement(visible = true, transformation(origin = {20, -78}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.mergeActions A(n = 3) annotation(
    Placement(visible = true, transformation(origin = {60, -12}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Action A2(qualifierType = SFC.Types.Qualifier.P) annotation(
    Placement(visible = true, transformation(origin = {20, -12}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Action A3(qualifierType = SFC.Types.Qualifier.P) annotation(
    Placement(visible = true, transformation(origin = {20, -56}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Action A1(qualifierType = SFC.Types.Qualifier.P) annotation(
    Placement(visible = true, transformation(origin = {20, 32}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.CounterAction countA annotation(
    Placement(visible = true, transformation(origin = {90, -12}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
equation
  connect(A.y, countA.increment) annotation(
    Line(points = {{70, -12}, {80, -12}}, color = {255, 0, 255}));
  connect(A3.actionOUT, A.mergeIN[3]) annotation(
    Line(points = {{30, -56}, {40, -56}, {40, -12}, {50, -12}, {50, -12}}));
  connect(A2.actionOUT, A.mergeIN[2]) annotation(
    Line(points = {{30, -12}, {50, -12}, {50, -12}, {50, -12}}));
  connect(A1.actionOUT, A.mergeIN[1]) annotation(
    Line(points = {{30, 32}, {40, 32}, {40, -12}, {50, -12}, {50, -12}}));
  connect(S1.X, A1.phase_active) annotation(
    Line(points = {{2, 32}, {8, 32}, {8, 32}, {10, 32}}, color = {255, 0, 255}));
  connect(S2.X, A2.phase_active) annotation(
    Line(points = {{2, -12}, {10, -12}, {10, -12}, {10, -12}}, color = {255, 0, 255}));
  connect(S3.X, A3.phase_active) annotation(
    Line(points = {{2, -56}, {10, -56}, {10, -56}, {10, -56}}, color = {255, 0, 255}));
  connect(T1.C, C1.y) annotation(
    Line(points = {{2, 54}, {9, 54}}, color = {255, 0, 255}));
  connect(T2.C, C2.y) annotation(
    Line(points = {{2, 10}, {9, 10}}, color = {255, 0, 255}));
  connect(T3.C, C3.y) annotation(
    Line(points = {{2, -34}, {9, -34}}, color = {255, 0, 255}));
  connect(T4.C, C4.y) annotation(
    Line(points = {{2, -78}, {9, -78}}, color = {255, 0, 255}));
  connect(T4.OUT, S0.IN) annotation(
    Line(points = {{-10, -80}, {-10, -88}, {-34, -88}, {-34, 94}, {-10, 94}, {-10, 86}}));
  connect(S3.OUT, T4.IN) annotation(
    Line(points = {{-10, -66}, {-10, -76}}));
  connect(S2.OUT, T3.IN) annotation(
    Line(points = {{-10, -22}, {-10, -32}}));
  connect(T3.OUT, S3.IN) annotation(
    Line(points = {{-10, -36}, {-10, -46}}));
  connect(S1.OUT, T2.IN) annotation(
    Line(points = {{-10, 22}, {-10, 12}}));
  connect(T2.OUT, S2.IN) annotation(
    Line(points = {{-10, 8}, {-10, -2}}));
  connect(S0.OUT, T1.IN) annotation(
    Line(points = {{-10, 66}, {-10, 56}}));
  connect(T1.OUT, S1.IN) annotation(
    Line(points = {{-10, 52}, {-10, 42}}));
annotation(
    __OpenModelica_simulationFlags(lv = "LOG_STATS", outputFormat = "mat", s = "dassl"),
    Documentation(info = "<html><head></head><body><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"><span class=\"Apple-style-span\" style=\"font-size: 12px; \">Test &nbsp;performing a&nbsp;<b>merging</b>&nbsp;between two actions &nbsp;<b>P</b>, when the first one&nbsp;<b>is not</b>&nbsp;associated to the<b>&nbsp;initial step</b>.<div><br></div><div>The output of the block MergeActions is expected to be a signal with as many pulses as the number of P actions connected. As for the single block action, a pulse cannot be seen graphically and to check the proper functioning of the block a counter is used.</div><div><br></div><div><div><b>A.y</b>&nbsp;signal will be true for a&nbsp;<i>\"small\"</i>&nbsp;instant every time the step associated to a P action becomes active ( steps S1, S2 and S3 in this test).</div><div><br></div><div>Being the action P&nbsp;connected to the initial step,&nbsp;<b>A.y</b>&nbsp;is initialised false.</div></div><div><br></div><div><b>N.B.</b>&nbsp;it is possible to connect consecutive actions of type P, in this test actions A1, A2 and A3 are all consecutive, and the output resulting from this representation is still consistent with the expectations.</div></span><div><br></div><div><br></div><div><br></div><div><br></div>
    
    <img width=\"400\" src=\"modelica://SFC/Images/tests/testMergeActionsPP2_y.png\">
    
    </body></html>"));end testMergeActions_PP2;
