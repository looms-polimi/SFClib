within SFC.Tests;
model testMergeActions_NN2
  SFC.BasicBlocks.InitialStep S0 annotation(
    Placement(visible = true, transformation(origin = {-10, 76}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Step S1 annotation(
    Placement(visible = true, transformation(origin = {-10, 32}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Step S2 annotation(
    Placement(visible = true, transformation(origin = {-10, -12}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Step S3 annotation(
    Placement(visible = true, transformation(origin = {-10, -56}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T1 annotation(
    Placement(visible = true, transformation(origin = {-10, 54}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T2 annotation(
    Placement(visible = true, transformation(origin = {-10, 10}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T3 annotation(
    Placement(visible = true, transformation(origin = {-10, -34}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Transition T4 annotation(
    Placement(visible = true, transformation(origin = {-10, -78}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C1(y = S0.t > 2)  annotation(
    Placement(visible = true, transformation(origin = {20, 54}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C2(y = S1.t > 1)  annotation(
    Placement(visible = true, transformation(origin = {20, 10}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C3(y = S2.t > 0.5)  annotation(
    Placement(visible = true, transformation(origin = {20, -34}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Condition C4(y = S3.t > 1.5)  annotation(
    Placement(visible = true, transformation(origin = {20, -78}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.mergeActions A(n = 2)  annotation(
    Placement(visible = true, transformation(origin = {60, -12}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Action A1(qualifierType = SFC.Types.Qualifier.N)  annotation(
    Placement(visible = true, transformation(origin = {20, 32}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
  SFC.BasicBlocks.Action A3(qualifierType = SFC.Types.Qualifier.N)  annotation(
    Placement(visible = true, transformation(origin = {20, -56}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));
equation
  connect(A3.actionOUT, A.mergeIN[2]) annotation(
    Line(points = {{30, -56}, {40, -56}, {40, -12}, {50, -12}, {50, -12}}));
  connect(A1.actionOUT, A.mergeIN[1]) annotation(
    Line(points = {{30, 32}, {40, 32}, {40, -12}, {50, -12}, {50, -12}}));
  connect(S3.X, A3.phase_active) annotation(
    Line(points = {{2, -56}, {10, -56}, {10, -56}, {10, -56}}, color = {255, 0, 255}));
  connect(S1.X, A1.phase_active) annotation(
    Line(points = {{2, 32}, {10, 32}, {10, 32}, {10, 32}}, color = {255, 0, 255}));
  connect(T1.C, C1.y) annotation(
    Line(points = {{2, 54}, {9, 54}}, color = {255, 0, 255}));
  connect(T2.C, C2.y) annotation(
    Line(points = {{2, 10}, {9, 10}}, color = {255, 0, 255}));
  connect(T3.C, C3.y) annotation(
    Line(points = {{2, -34}, {9, -34}}, color = {255, 0, 255}));
  connect(T4.C, C4.y) annotation(
    Line(points = {{2, -78}, {9, -78}}, color = {255, 0, 255}));
  connect(T4.OUT, S0.IN) annotation(
    Line(points = {{-10, -80}, {-10, -88}, {-34, -88}, {-34, 94}, {-10, 94}, {-10, 86}}));
  connect(S3.OUT, T4.IN) annotation(
    Line(points = {{-10, -66}, {-10, -76}}));
  connect(S2.OUT, T3.IN) annotation(
    Line(points = {{-10, -22}, {-10, -32}}));
  connect(T3.OUT, S3.IN) annotation(
    Line(points = {{-10, -36}, {-10, -46}}));
  connect(S1.OUT, T2.IN) annotation(
    Line(points = {{-10, 22}, {-10, 12}}));
  connect(T2.OUT, S2.IN) annotation(
    Line(points = {{-10, 8}, {-10, -2}}));
  connect(S0.OUT, T1.IN) annotation(
    Line(points = {{-10, 66}, {-10, 56}}));
  connect(T1.OUT, S1.IN) annotation(
    Line(points = {{-10, 52}, {-10, 42}}));
annotation(
    Documentation(info = "<html><head></head><body><meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"><span class=\"Apple-style-span\" style=\"font-size: 12px; \">Test &nbsp;performing a&nbsp;<b>merging</b>&nbsp;between two actions&nbsp;&nbsp;<b>N</b>, when the first one&nbsp;<b>is not</b>&nbsp;associated to the<b>&nbsp;initial step</b>.<div><br></div><div>The output of the block MergeActions is expected to be a signal that has value true when action A1 is performed and that keeps that value until the associated step is deactivated. The same behaviour is expected for action A3.</div><div><br></div><div><div><b>A.y</b>&nbsp;signal will be true for the all duration of step S1 and S3 and it will be false for the all duration of steps S0 and S2.</div><div><br></div><div>Being the action N&nbsp;<b>not</b>&nbsp;connected to the initial step,&nbsp;<b>A.y</b>&nbsp;is initialised false.</div></div><div><br></div><div><b>N.B.</b>&nbsp;it is possible to connect consecutive actions of type N (actions connected to consecutive steps). See <i>testMergeActions_NN1</i>&nbsp;for better clarifications.</div></span><div><br></div><div><br></div><div><br></div><div>&nbsp;
    
    <img width=\"400\" src=\"modelica://SFC/Images/tests/testMergeActionsNN2_y.png\"></div></body></html>"));end testMergeActions_NN2;